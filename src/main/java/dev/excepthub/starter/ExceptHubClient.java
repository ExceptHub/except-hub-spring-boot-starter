package dev.excepthub.starter;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.*;
import org.springframework.web.client.RestTemplate;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@RequiredArgsConstructor
public class ExceptHubClient {

    private final ExceptHubProperties properties;
    private final RestTemplate restTemplate = new RestTemplate();

    public void sendError(Exception exception, String stackTrace, Map<String, Object> httpContext) {
        if (!properties.isEnabled()) {
            return;
        }

        try {
            Map<String, Object> payload = buildPayload(exception, stackTrace, httpContext, null);

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.set("X-API-Key", properties.getApiKey());

            log.info(headers.get("X-API-Key").toString());

            HttpEntity<Map<String, Object>> request = new HttpEntity<>(payload, headers);

            restTemplate.postForEntity(
                    properties.getEndpoint(),
                    request,
                    String.class
            );

            log.debug("✅ Error sent to ExceptHub");

        } catch (Exception e) {
            log.error("❌ Failed to send error to ExceptHub: {}", e.getMessage());
        }
    }

    public void sendScheduledTaskError(Exception exception, String stackTrace,
                                      String scheduledTaskClass, String scheduledTaskMethod, String cron) {
        if (!properties.isEnabled()) {
            return;
        }

        try {
            Map<String, String> scheduledContext = new HashMap<>();
            scheduledContext.put("scheduledTaskClass", scheduledTaskClass);
            scheduledContext.put("scheduledTaskMethod", scheduledTaskMethod);
            scheduledContext.put("scheduledTaskCron", cron);

            Map<String, Object> payload = buildPayload(exception, stackTrace, null, scheduledContext);

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.set("X-API-Key", properties.getApiKey());

            HttpEntity<Map<String, Object>> request = new HttpEntity<>(payload, headers);

            restTemplate.postForEntity(
                    properties.getEndpoint(),
                    request,
                    String.class
            );

            log.debug("✅ Scheduled task error sent to ExceptHub: {} - {}", scheduledTaskClass, exception.getClass().getSimpleName());

        } catch (Exception e) {
            log.error("❌ Failed to send scheduled task error to ExceptHub: {}", e.getMessage());
        }
    }

    private Map<String, Object> buildPayload(Exception exception, String stackTrace,
                                             Map<String, Object> httpContext,
                                             Map<String, String> scheduledContext) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("timestamp", Instant.now().toString());
        payload.put("service", properties.getService());
        payload.put("environment", properties.getEnvironment());
        payload.put("gitSha", detectGitSha()); // ✅ Auto-detect

        Map<String, Object> exceptionData = new HashMap<>();
        exceptionData.put("type", exception.getClass().getName());
        exceptionData.put("message", exception.getMessage());
        exceptionData.put("stackTrace", stackTrace);

        payload.put("exception", exceptionData);
        payload.put("http", httpContext);

        // Add scheduled task context if present
        if (scheduledContext != null) {
            payload.put("scheduledTaskClass", scheduledContext.get("scheduledTaskClass"));
            payload.put("scheduledTaskMethod", scheduledContext.get("scheduledTaskMethod"));
            payload.put("scheduledTaskCron", scheduledContext.get("scheduledTaskCron"));
        }

        return payload;
    }

    // ✅ Auto-detect Git SHA from CI/CD env vars or git.properties
    private String detectGitSha() {
        // 1. Try CI/CD environment variables first (for production builds)
        String sha = detectFromCI();
        if (sha != null) {
            return sha;
        }

        // 2. Try git.properties file (generated by git-commit-id-plugin)
        sha = detectFromGitProperties();
        if (sha != null) {
            return sha;
        }

        // 3. Try reading from .git directory (local development fallback)
        sha = detectFromGitDirectory();
        if (sha != null) {
            return sha;
        }

        // 4. Ultimate fallback: try to detect current branch name
        String branch = detectBranchName();
        if (branch != null && !branch.isEmpty()) {
            log.info("ℹ️ No Git SHA detected, using branch name as fallback: {}", branch);
            return branch;
        }

        // 5. Last resort fallback
        log.warn("⚠️ No Git SHA or branch detected, using fallback: master");
        return "master";
    }

    private String detectFromCI() {
        // GitHub Actions
        String sha = System.getenv("GITHUB_SHA");
        if (sha != null && !sha.isEmpty()) {
            log.info("✅ Detected Git SHA from GITHUB_SHA: {}", sha);
            return sha;
        }

        // GitLab CI
        sha = System.getenv("CI_COMMIT_SHA");
        if (sha != null && !sha.isEmpty()) {
            log.info("✅ Detected Git SHA from CI_COMMIT_SHA: {}", sha);
            return sha;
        }

        // Jenkins
        sha = System.getenv("GIT_COMMIT");
        if (sha != null && !sha.isEmpty()) {
            log.info("✅ Detected Git SHA from GIT_COMMIT: {}", sha);
            return sha;
        }

        // CircleCI
        sha = System.getenv("CIRCLE_SHA1");
        if (sha != null && !sha.isEmpty()) {
            log.info("✅ Detected Git SHA from CIRCLE_SHA1: {}", sha);
            return sha;
        }

        return null;
    }

    private String detectFromGitProperties() {
        try {
            java.util.Properties properties = new java.util.Properties();
            java.io.InputStream input = getClass().getClassLoader().getResourceAsStream("git.properties");

            if (input != null) {
                properties.load(input);
                String sha = properties.getProperty("git.commit.id.abbrev");
                if (sha == null) {
                    sha = properties.getProperty("git.commit.id");
                }
                if (sha != null && !sha.isEmpty()) {
                    log.info("✅ Detected Git SHA from git.properties: {}", sha);
                    return sha;
                }
            }
        } catch (Exception e) {
            log.info("ℹ️ Could not read git.properties: {}", e.getMessage());
        }
        return null;
    }

    private String detectFromGitDirectory() {
        try {
            java.io.File gitHead = new java.io.File(".git/HEAD");
            if (gitHead.exists()) {
                String content = new String(java.nio.file.Files.readAllBytes(gitHead.toPath())).trim();

                // If HEAD points to a branch (ref: refs/heads/branch-name)
                if (content.startsWith("ref:")) {
                    String refPath = content.substring(5).trim(); // Remove "ref: "
                    java.io.File refFile = new java.io.File(".git/" + refPath);
                    if (refFile.exists()) {
                        String sha = new String(java.nio.file.Files.readAllBytes(refFile.toPath())).trim();
                        log.info("✅ Detected Git SHA from .git directory: {}", sha);
                        return sha;
                    }
                } else {
                    // HEAD contains commit SHA directly (detached HEAD)
                    log.info("✅ Detected Git SHA from .git/HEAD: {}", content);
                    return content;
                }
            }
        } catch (Exception e) {
            log.info("ℹ️ Could not read from .git directory: {}", e.getMessage());
        }
        return null;
    }

    private String detectBranchName() {
        try {
            java.io.File gitHead = new java.io.File(".git/HEAD");
            if (gitHead.exists()) {
                String content = new String(java.nio.file.Files.readAllBytes(gitHead.toPath())).trim();

                // If HEAD points to a branch (ref: refs/heads/branch-name)
                if (content.startsWith("ref: refs/heads/")) {
                    String branch = content.substring("ref: refs/heads/".length());
                    log.info("✅ Detected branch name: {}", branch);
                    return branch;
                }
            }
        } catch (Exception e) {
            log.info("ℹ️ Could not detect branch name: {}", e.getMessage());
        }
        return null;
    }
}
